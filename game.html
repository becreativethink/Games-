<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WordWar â€” Game</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

<!-- Navbar -->
<nav class="navbar">
  <a href="index.html" class="nav-logo"><span class="w1">WORD</span><span class="w2">WAR</span></a>
  <div class="nav-links">
    <a href="index.html" class="nav-link m-show">â† Home</a>
    <div class="nav-sep"></div>
    <a href="profile.html" class="user-badge">
      <img class="ub-avatar" id="nav-avatar" src="" alt="" />
      <span class="ub-name"  id="nav-username">â€¦</span>
      <div class="online-dot"></div>
    </a>
  </div>
</nav>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SETUP SCREENS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

<!-- OFFLINE SETUP -->
<div id="screen-offline" class="hidden setup-wrap">
  <div class="setup-card card card-elevated page-enter">
    <div class="setup-head">
      <div class="setup-ic">ğŸ¤</div>
      <div>
        <h2>Offline Mode</h2>
        <p class="text-sm text-muted">Player 1 sets the secret word, Player 2 guesses.</p>
      </div>
    </div>
    <div class="divider"></div>
    <div class="form-group">
      <label class="form-label">Secret Word (hidden) â€” letters Aâ€“Z only</label>
      <input class="form-control" id="off-secret" type="password" placeholder="Type secretlyâ€¦" maxlength="12" />
    </div>
    <div class="form-group">
      <label class="form-label">Word Length (auto-detected)</label>
      <input class="form-control" id="off-len" type="number" value="5" min="2" max="12" readonly />
    </div>
    <div class="form-group">
      <label class="form-label">Max Attempts</label>
      <input class="form-control" id="off-attempts" type="number" value="6" min="3" max="10" />
    </div>
    <div class="flex gap-8 mt-16">
      <button class="btn btn-primary flex-1" onclick="startOfflineGame()">Start Game â†’</button>
      <a href="index.html" class="btn btn-ghost">Cancel</a>
    </div>
  </div>
</div>

<!-- ONLINE SETUP -->
<div id="screen-online" class="hidden setup-wrap">
  <div class="setup-card wide card card-elevated page-enter">
    <div class="setup-head">
      <div class="setup-ic">ğŸŒ</div>
      <div>
        <h2>Online Multiplayer</h2>
        <p class="text-sm text-muted">Host a room or join with a Room ID.</p>
      </div>
    </div>
    <div class="divider"></div>

    <div class="tab-strip">
      <button class="tab-btn active" id="tab-host"  onclick="switchOnlineTab('host')">Host a Room</button>
      <button class="tab-btn"        id="tab-guest" onclick="switchOnlineTab('guest')">Join a Room</button>
    </div>

    <!-- Host panel -->
    <div id="host-panel">
      <div class="form-group">
        <label class="form-label">Secret Word (opponent guesses this) â€” letters Aâ€“Z only</label>
        <input class="form-control" id="h-secret" type="password" placeholder="Type your secret wordâ€¦" maxlength="12" />
      </div>
      <div class="flex gap-12">
        <div class="form-group flex-1">
          <label class="form-label">Max Attempts</label>
          <input class="form-control" id="h-attempts" type="number" value="6" min="3" max="10" />
        </div>
        <div class="form-group flex-1">
          <label class="form-label">Bet Score (you have: <span id="h-score-cur" class="text-accent">â€”</span>)</label>
          <input class="form-control" id="h-bet" type="number" value="50" min="0" />
        </div>
      </div>
      <div class="flex gap-8 mt-8">
        <button class="btn btn-primary flex-1" onclick="createRoom()">Create Room â†’</button>
        <a href="index.html" class="btn btn-ghost">Cancel</a>
      </div>
    </div>

    <!-- Guest panel -->
    <div id="guest-panel" class="hidden">
      <p class="text-muted text-sm mb-16">Ask the host for their 6-character Room ID.</p>
      <div class="form-group">
        <label class="form-label">Room ID</label>
        <input class="form-control" id="g-room-id" type="text" placeholder="AB12CD" maxlength="6"
          style="font-family:var(--mono);letter-spacing:0.25em;text-transform:uppercase;text-align:center;font-size:1.7rem;padding:14px;" />
      </div>
      <div class="flex gap-8 mt-8">
        <button class="btn btn-primary flex-1" onclick="joinRoom()">Join Room â†’</button>
        <a href="index.html" class="btn btn-ghost">Cancel</a>
      </div>
    </div>
  </div>
</div>

<!-- WAITING ROOM -->
<div id="screen-waiting" class="hidden setup-wrap">
  <div class="setup-card card card-elevated text-center page-enter">
    <div style="font-size:3rem;margin-bottom:12px;animation:pdot 1.5s infinite;">â³</div>
    <h2 class="mb-8">Waiting for Opponent</h2>
    <p class="text-muted text-sm mb-20">Share this Room ID:</p>
    <div class="room-id-display mb-8" id="room-id-show" onclick="copyRoomId()">â€”</div>
    <p class="text-faint text-xs mb-20">Click to copy</p>
    <button class="btn btn-danger btn-sm" onclick="cancelRoom()">Cancel Room</button>
  </div>
</div>

<!-- DAILY SETUP -->
<div id="screen-daily" class="hidden setup-wrap">
  <div class="setup-card card card-elevated text-center page-enter">
    <div style="font-size:3rem;margin-bottom:12px;">ğŸ“…</div>
    <h2 class="mb-8">Daily Challenge</h2>
    <p class="text-muted text-sm mb-16">60 seconds. One word. Beat the clock.</p>

    <div class="card mb-16" style="background:rgba(240,180,41,0.05);border-color:rgba(240,180,41,0.18);">
      <div class="flex justify-between mb-8">
        <span class="text-muted text-sm">Reward Money</span>
        <span class="text-gold text-mono fw-700" id="d-reward-money">â€”</span>
      </div>
      <div class="flex justify-between mb-8">
        <span class="text-muted text-sm">Reward Score</span>
        <span class="text-accent text-mono fw-700" id="d-reward-score">â€”</span>
      </div>
      <div class="flex justify-between">
        <span class="text-muted text-sm">Max Attempts</span>
        <span class="text-mono fw-700" id="d-attempts">â€”</span>
      </div>
    </div>

    <div id="d-already-played" class="hidden">
      <div class="tag tag-green" style="display:inline-flex;padding:8px 18px;font-size:0.82rem;border-radius:var(--rS);">
        âœ“ Already completed today!
      </div>
      <p class="text-muted text-sm mt-12">Come back tomorrow for a new word.</p>
      <a href="index.html" class="btn btn-ghost btn-full mt-16">â† Back Home</a>
    </div>

    <div id="d-start-wrap">
      <button class="btn btn-gold btn-full btn-xl" onclick="startDailyGame()">âš¡ Start Challenge</button>
      <a href="index.html" class="btn btn-ghost btn-sm mt-8">Cancel</a>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-game" class="hidden">
  <div class="game-layout">

    <!-- Board -->
    <div class="game-main">
      <div class="game-status">
        <h2 id="game-title" class="text-display">WORD WAR</h2>
        <p class="text-muted" id="game-subtitle">Guess the hidden word</p>
      </div>

      <!-- Timer (daily only) -->
      <div id="timer-area" class="hidden">
        <div id="timer-el"></div>
      </div>

      <!-- Board grid -->
      <div class="game-board" id="game-board"></div>

      <!-- Guess input -->
      <div class="guess-input-wrap" id="guess-input-area">
        <input class="guess-input" id="guess-input" type="text" placeholder="GUESS"
          maxlength="12" autocomplete="off" autocorrect="off"
          autocapitalize="characters" spellcheck="false" />
        <button class="btn btn-primary" id="submit-btn" onclick="submitGuess()">GO</button>
      </div>

      <!-- Keyboard -->
      <div class="keyboard" id="keyboard"></div>
    </div>

    <!-- Sidebar -->
    <div class="game-sidebar">

      <!-- Game info -->
      <div class="sb-card">
        <div class="sb-title" id="sb-mode-lbl">Game Info</div>
        <div class="sb-row"><span class="lbl">Attempts Left</span><span class="val" id="sb-attempts">â€”</span></div>
        <div class="sb-row"><span class="lbl">Word Length</span><span class="val" id="sb-len">â€”</span></div>
        <div class="sb-row hidden" id="sb-bet-row"><span class="lbl">Bet</span><span class="val text-gold" id="sb-bet">â€”</span></div>
      </div>

      <!-- Opponent card (online only) -->
      <div class="sb-card hidden" id="opp-card">
        <div class="sb-title">Opponent</div>
        <div class="flex items-center gap-12">
          <img id="opp-avatar" src="" alt=""
               style="width:36px;height:36px;border-radius:50%;border:2px solid var(--b2);flex-shrink:0;" />
          <div class="min-w-0">
            <div class="fw-700 truncate" id="opp-name">â€”</div>
            <div class="text-xs text-faint" id="opp-status">Connectingâ€¦</div>
          </div>
        </div>
      </div>

      <!-- Match log (host view) -->
      <div class="sb-card hidden" id="log-card">
        <div class="sb-title">Match Log</div>
        <div id="online-log" style="font-size:0.76rem;color:var(--text2);max-height:180px;overflow-y:auto;"></div>
      </div>

    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESULT OVERLAY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="result-overlay" id="result-overlay">
  <div class="result-card">
    <span class="res-emoji" id="res-emoji">ğŸ†</span>
    <h2 class="res-title" id="res-title">Victory!</h2>
    <div class="res-word" id="res-word">WORD</div>
    <p class="res-msg text-muted" id="res-msg"></p>
    <div class="res-btns">
      <button class="btn btn-primary" onclick="playAgain()">âš¡ Play Again</button>
      <a href="index.html" class="btn btn-ghost">â† Home</a>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BANNER AD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="ad-banner">
  <!-- BEGIN EZMOB TAG -->
  <SCRIPT TYPE="text/javascript">
  var __jscp=function(){for(var b=0,a=window;a!=a.parent;)++b,a=a.parent;if(a=window.parent==window?document.URL:document.referrer){var c=a.indexOf("://");0<=c&&(a=a.substring(c+3));c=a.indexOf("/");0<=c&&(a=a.substring(0,c))}var b={pu:a,"if":b,rn:new Number(Math.floor(99999999*Math.random())+1)},a=[],d;for(d in b)a.push(d+"="+encodeURIComponent(b[d]));return encodeURIComponent(a.join("&"))};
  document.write('<S' + 'CRIPT TYPE="text/javascript" SRC="//cpm.ezmob.com/tag?zone_id=338024&size=320x50&subid=&j=' + __jscp() + '"></S' + 'CRIPT>');
  </SCRIPT>
  <!-- END EZMOB TAG -->
</div>

<script type="module">
import {
  requireAuth, loadSession, saveSession, avatarUrl, fmtNum,
  sha256, generateRoomId, todayStr,
  db, ref, set, get, update, onValue, off, push, remove
} from './firebase-config.js';
import {
  showToast, evaluateGuess, buildTileRow, buildEmptyRow, shakeRow,
  updateKeyboard, buildKeyboard, CountdownTimer,
  playSound, confettiBurst, ACHIEVEMENTS, checkAchievements
} from './main.js';

// â”€â”€ Auth â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentUser = requireAuth('login.html');
if (!currentUser) throw 0;

document.getElementById('nav-username').textContent = currentUser.username;
document.getElementById('nav-avatar').src = avatarUrl(currentUser.photoURL, currentUser.username);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE â€” single source of truth
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let mode         = sessionStorage.getItem('ww_mode') || 'offline';
let secretWord   = '';        // plaintext secret; needed by whichever side evaluates guesses
let maxAttempts  = 6;
let wordLength   = 5;
let guessCount   = 0;         // attempts used so far
let gameOver     = false;     // HARD LOCK â€” set to true the moment game ends; prevents any re-entry
let currentGuess = '';
let timer        = null;
let roomId       = null;
let isHost       = false;
let betScore     = 0;
let _guessUnsub  = null;      // Firebase onValue unsubscribe handle for guess listener

// â”€â”€ Screen switcher â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showScreen(id) {
  ['screen-offline','screen-online','screen-daily','screen-waiting','screen-game']
    .forEach(s => document.getElementById(s).classList.toggle('hidden', s !== id));
}

// â”€â”€ Bootstrap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  // Refresh user data from Firebase
  const snap = await get(ref(db, 'users/' + currentUser.uid));
  if (snap.exists()) {
    currentUser = { ...currentUser, ...snap.val() };
    saveSession(currentUser);
  }

  if      (mode === 'offline') { initOfflineScreen(); }
  else if (mode === 'online')  { initOnlineScreen();  }
  else if (mode === 'daily')   { await initDailyScreen(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OFFLINE MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initOfflineScreen() {
  showScreen('screen-offline');
  document.getElementById('off-secret').addEventListener('input', e => {
    // Reflect length so player sees it updating
    document.getElementById('off-len').value = e.target.value.length || '';
  });
}

window.startOfflineGame = function() {
  const raw = document.getElementById('off-secret').value.trim().toUpperCase();

  if (raw.length < 2)          { showToast('Word must be at least 2 letters.', 'warn'); return; }
  if (!/^[A-Z]+$/.test(raw))  { showToast('Secret word must contain letters only (Aâ€“Z). No numbers or symbols.', 'warn'); return; }

  secretWord  = raw;
  maxAttempts = parseInt(document.getElementById('off-attempts').value, 10) || 6;
  wordLength  = raw.length;

  startBoard('ğŸ¤ OFFLINE MODE', 'Player 2: Guess the secret word!');
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ONLINE MODE â€” HOST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initOnlineScreen() {
  document.getElementById('h-score-cur').textContent = fmtNum(currentUser.score);
  showScreen('screen-online');
}

window.switchOnlineTab = function(tab) {
  document.getElementById('tab-host').classList.toggle('active',   tab === 'host');
  document.getElementById('tab-guest').classList.toggle('active',  tab === 'guest');
  document.getElementById('host-panel').classList.toggle('hidden', tab !== 'host');
  document.getElementById('guest-panel').classList.toggle('hidden',tab !== 'guest');
};

window.createRoom = async function() {
  const secret   = document.getElementById('h-secret').value.trim().toUpperCase();
  const attempts = parseInt(document.getElementById('h-attempts').value, 10) || 6;
  const bet      = Math.max(0, parseInt(document.getElementById('h-bet').value, 10) || 0);

  // Validate word: letters only
  if (secret.length < 2)         { showToast('Enter a valid secret word (min 2 letters).', 'warn'); return; }
  if (!/^[A-Z]+$/.test(secret))  { showToast('Secret word must contain letters only (Aâ€“Z).', 'warn'); return; }

  // Check host has enough score for the bet
  const fresh = await get(ref(db, 'users/' + currentUser.uid));
  const hData = fresh.val();
  if (bet > (hData.score || 0)) { showToast('Insufficient score for this bet.', 'error'); return; }

  // Hash for storage integrity (not for client-side security)
  const hash = await sha256(secret.toLowerCase());

  roomId      = generateRoomId();
  isHost      = true;
  secretWord  = secret;
  maxAttempts = attempts;
  wordLength  = secret.length;
  betScore    = bet;

  // Write room to Firebase.
  // secretWord is stored so the guest can load it after joining.
  // In a production environment this would live behind server-side logic.
  await set(ref(db, 'rooms/' + roomId), {
    host:             currentUser.username,
    hostUid:          currentUser.uid,
    guest:            null,
    guestUid:         null,
    secretWordHash:   hash,
    secretWord:       secret,           // loaded by guest AFTER joining (status: active)
    secretWordLength: secret.length,
    attempts,
    betScore:         bet,
    status:           'waiting',
    winner:           null,
    createdAt:        Date.now()
  });

  // Deduct host's bet up front
  if (bet > 0) {
    await update(ref(db, 'users/' + currentUser.uid), {
      score: (hData.score || 0) - bet
    });
  }

  document.getElementById('room-id-show').textContent = roomId;
  showScreen('screen-waiting');
  waitForGuest();
};

window.copyRoomId = function() {
  navigator.clipboard?.writeText(roomId)
    .then(() => showToast('Room ID copied! ğŸ“‹', 'success'))
    .catch(() => showToast(`Copy manually: ${roomId}`, 'warn'));
};

window.cancelRoom = async function() {
  if (_guessUnsub) { _guessUnsub(); _guessUnsub = null; }

  if (roomId) {
    // Refund bet
    if (betScore > 0) {
      const snap = await get(ref(db, 'users/' + currentUser.uid));
      if (snap.exists()) {
        await update(ref(db, 'users/' + currentUser.uid), {
          score: (snap.val().score || 0) + betScore
        });
      }
    }
    await update(ref(db, 'rooms/' + roomId), { status: 'cancelled' });
  }
  window.location.href = 'index.html';
};

/**
 * Host waits in the waiting room until a guest joins.
 * Uses onValue with a self-detaching handler.
 */
function waitForGuest() {
  const rRef = ref(db, 'rooms/' + roomId);

  const unsub = onValue(rRef, snap => {
    if (!snap.exists()) return;
    const room = snap.val();

    if (room.status === 'active' && room.guest) {
      unsub();    // detach â€” we don't need this listener anymore
      startHostView(room);
    }

    if (room.status === 'cancelled') {
      unsub();
      showToast('Room was cancelled.', 'warn');
      window.location.href = 'index.html';
    }
  });
}

/** Host enters spectator view â€” watches guest guesses in real-time */
function startHostView(room) {
  document.getElementById('opp-card').classList.remove('hidden');
  document.getElementById('log-card').classList.remove('hidden');
  document.getElementById('opp-name').textContent   = room.guest;
  document.getElementById('opp-avatar').src         = avatarUrl('', room.guest);
  document.getElementById('opp-status').textContent = 'Guessingâ€¦';

  // Host knows the word, show it in the title for reference
  startBoard(`ğŸŒ HOST Â· Your word: ${secretWord}`, `${room.guest} is guessing`, false, true);
  document.getElementById('sb-mode-lbl').textContent = 'ğŸŒ Online Â· Host';
  document.getElementById('sb-bet-row').classList.remove('hidden');
  document.getElementById('sb-bet').textContent      = room.betScore;

  // Host doesn't type â€” hide input controls
  document.getElementById('guess-input-area').classList.add('hidden');
  document.getElementById('keyboard').style.display = 'none';

  listenToGuestGuesses();
}

/**
 * Host listens to the /guesses node and renders each guess onto the board.
 *
 * BUG FIXES applied here:
 * 1. Track `lastCount` to avoid re-processing the full array on every update
 * 2. gameOver guard prevents handleGameEnd from firing more than once
 * 3. Host does NOT write DB outcome â€” that's the guest's job
 */
function listenToGuestGuesses() {
  const gRef = ref(db, 'rooms/' + roomId + '/guesses');
  let lastCount = 0;  // how many guesses we've already rendered

  _guessUnsub = onValue(gRef, snap => {
    if (!snap.exists() || gameOver) return;

    const guesses = Object.values(snap.val()).sort((a, b) => a.ts - b.ts);
    const board   = document.getElementById('game-board');
    const rows    = board.querySelectorAll('.guess-row');
    const log     = document.getElementById('online-log');

    // Only process NEW guesses (those beyond lastCount)
    for (let i = lastCount; i < guesses.length; i++) {
      const g      = guesses[i];
      const result = evaluateGuess(secretWord, g.guess);

      // Render tile row
      if (rows[i]) buildTileRow(rows[i], g.guess, result);

      // Append to log
      const entry = document.createElement('div');
      entry.style.cssText = 'margin-bottom:3px;padding:2px 8px;background:var(--s1);border-radius:5px;font-family:var(--mono);letter-spacing:0.1em;';
      entry.textContent   = g.guess.toUpperCase();
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }

    lastCount = guesses.length;

    // Update sidebar
    const used = guesses.length;
    document.getElementById('sb-attempts').textContent = maxAttempts - used;
    document.getElementById('opp-status').textContent  = `${used} / ${maxAttempts} guesses used`;

    // Check if the room has been marked finished (by the guest side)
    get(ref(db, 'rooms/' + roomId)).then(rSnap => {
      if (!rSnap.exists() || gameOver) return;
      const rData = rSnap.val();
      if (rData.status === 'finished') {
        if (_guessUnsub) { _guessUnsub(); _guessUnsub = null; }
        const hostWon = rData.winner === currentUser.username;
        showHostResult(hostWon, secretWord, rData.winner);
      }
    });
  });
}

/** Show result to host without touching the database (guest already wrote it) */
function showHostResult(hostWon, word, winner) {
  if (gameOver) return;
  gameOver = true;

  if (hostWon) { confettiBurst(); playSound('win');  }
  else         {                  playSound('lose'); }

  setTimeout(() => {
    document.getElementById('res-emoji').textContent = hostWon ? 'ğŸ†' : 'ğŸ’€';
    document.getElementById('res-title').textContent = hostWon ? 'YOU WIN!' : 'YOU LOSE!';
    document.getElementById('res-word').textContent  = word;
    document.getElementById('res-msg').textContent   = hostWon
      ? `${winner} couldn't crack your word! +${betScore * 2} â­ awarded.`
      : `${winner} guessed your word! They take the pot.`;
    document.getElementById('result-overlay').classList.add('open');
  }, 700);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ONLINE MODE â€” GUEST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.joinRoom = async function() {
  const id = document.getElementById('g-room-id').value.trim().toUpperCase();
  if (id.length !== 6) { showToast('Room ID must be 6 characters.', 'warn'); return; }

  const rRef = ref(db, 'rooms/' + id);
  const snap = await get(rRef);

  if (!snap.exists())            { showToast('Room not found.', 'error'); return; }
  const room = snap.val();

  // Safety checks
  if (room.status !== 'waiting') { showToast('Room is not available.', 'error'); return; }
  if (room.host === currentUser.username) { showToast("You can't join your own room.", 'warn'); return; }
  if (room.guest)                { showToast('Room already has a guest.', 'error'); return; }

  // Check guest has enough score
  const mySnap = await get(ref(db, 'users/' + currentUser.uid));
  const myData = mySnap.val();
  if ((room.betScore || 0) > (myData.score || 0)) {
    showToast(`Need at least ${room.betScore} â­ score to join.`, 'error'); return;
  }

  // Deduct guest's bet
  if (room.betScore > 0) {
    await update(ref(db, 'users/' + currentUser.uid), {
      score: (myData.score || 0) - room.betScore
    });
  }

  // â”€â”€ CRITICAL FIX: Load secretWord from the room NOW â”€â”€â”€â”€â”€â”€â”€
  // Previously secretWord was never set for the guest, causing evaluateGuess('')
  // to always return [] which .every() vacuously evaluates as true â†’ instant "win".
  roomId      = id;
  isHost      = false;
  betScore    = room.betScore     || 0;
  maxAttempts = room.attempts;
  wordLength  = room.secretWordLength;
  secretWord  = room.secretWord.toUpperCase();   // â† THE FIX

  // Mark room active â€” host's waitForGuest listener will detect this
  await update(rRef, {
    guest:    currentUser.username,
    guestUid: currentUser.uid,
    status:   'active'
  });

  startGuestView(room);
};

/** Guest enters interactive guessing view */
function startGuestView(room) {
  document.getElementById('opp-card').classList.remove('hidden');
  document.getElementById('opp-name').textContent   = room.host;
  document.getElementById('opp-avatar').src         = avatarUrl('', room.host);
  document.getElementById('opp-status').textContent = 'Hosting';

  startBoard('ğŸŒ MULTIPLAYER', `Vs ${room.host} Â· Bet: ${room.betScore || 0} â­`);
  document.getElementById('sb-mode-lbl').textContent = 'ğŸŒ Online Â· Guest';
  document.getElementById('sb-bet-row').classList.remove('hidden');
  document.getElementById('sb-bet').textContent      = room.betScore;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAILY MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function initDailyScreen() {
  const today     = todayStr();
  const dailySnap = await get(ref(db, 'dailyWord'));

  if (!dailySnap.exists()) {
    showToast('No daily challenge set yet. Check back soon!', 'warn');
    document.getElementById('d-start-wrap').classList.add('hidden');
    showScreen('screen-daily');
    return;
  }

  const daily = dailySnap.val();
  document.getElementById('d-reward-money').textContent = 'ğŸ’° ' + (daily.rewardMoney || 50);
  document.getElementById('d-reward-score').textContent = 'â­ ' + (daily.rewardScore || 100);
  document.getElementById('d-attempts').textContent     = daily.attempts || 6;

  // Check if already played today
  const resSnap = await get(ref(db, `dailyResults/${today}/${currentUser.username}`));
  if (resSnap.exists()) {
    document.getElementById('d-already-played').classList.remove('hidden');
    document.getElementById('d-start-wrap').classList.add('hidden');
  }

  window._dailyData = daily;
  showScreen('screen-daily');
}

window.startDailyGame = function() {
  const daily = window._dailyData;
  if (!daily) { showToast('Daily data missing.', 'error'); return; }

  secretWord  = daily.word.toUpperCase();
  maxAttempts = daily.attempts || 6;
  wordLength  = secretWord.length;

  startBoard('ğŸ“… DAILY CHALLENGE', 'â± 60 seconds â€” guess the word!', true);

  timer = new CountdownTimer({
    totalSeconds: 60,
    containerEl:  document.getElementById('timer-el'),
    onEnd: () => {
      if (!gameOver) handleGameEnd(false, secretWord);
    }
  });
  timer.start();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOARD SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startBoard(title, subtitle, showTimer = false, hostView = false) {
  showScreen('screen-game');
  document.getElementById('game-title').textContent    = title;
  document.getElementById('game-subtitle').textContent = subtitle;

  // Build empty grid rows
  const board = document.getElementById('game-board');
  board.innerHTML = '';
  for (let i = 0; i < maxAttempts; i++) {
    const row     = document.createElement('div');
    row.className = 'guess-row';
    row.id        = `row-${i}`;
    buildEmptyRow(row, wordLength);
    board.appendChild(row);
  }

  document.getElementById('sb-len').textContent      = wordLength;
  document.getElementById('sb-attempts').textContent = maxAttempts;  // start with full attempts

  if (showTimer) document.getElementById('timer-area').classList.remove('hidden');

  if (!hostView) {
    buildKeyboard(document.getElementById('keyboard'), handleKey);
    attachInputListeners();
    setTimeout(() => document.getElementById('guess-input').focus(), 150);
  }
}

/** Wire up the text input field with validation */
function attachInputListeners() {
  const inp = document.getElementById('guess-input');
  inp.maxLength = wordLength;

  // â”€â”€ keydown: block non-letter keys before they enter the field â”€â”€
  inp.addEventListener('keydown', e => {
    if (e.key === 'Enter') { submitGuess(); return; }
    // Pass through control keys (Backspace, Delete, Arrow keys, Tab, etc.)
    if (e.key.length > 1) return;
    // Block anything that isn't a letter A-Z
    if (!/^[a-zA-Z]$/.test(e.key)) {
      e.preventDefault();
      showToast('Only letters Aâ€“Z allowed.', 'warn');
    }
  });

  // â”€â”€ input: clean and uppercase in case anything slipped through â”€â”€
  inp.addEventListener('input', e => {
    const clean = e.target.value.replace(/[^a-zA-Z]/g, '').toUpperCase();
    if (e.target.value !== clean) e.target.value = clean;
    updateCurrentRow(clean);
  });
}

// â”€â”€ On-screen keyboard handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleKey(k) {
  if (gameOver) return;
  const inp = document.getElementById('guess-input');

  if (k === 'âŒ«') {
    inp.value = inp.value.slice(0, -1);
  } else if (k === 'ENTER') {
    submitGuess();
    return;
  } else if (/^[A-Z]$/.test(k) && inp.value.length < wordLength) {
    inp.value += k;
    playSound('type');
  }
  updateCurrentRow(inp.value);
}

/** Mirror typed letters onto the current board row */
function updateCurrentRow(val) {
  currentGuess  = val.toUpperCase();
  const row     = document.getElementById(`row-${guessCount}`);
  if (!row) return;

  row.querySelectorAll('.tile').forEach((t, i) => {
    t.textContent = currentGuess[i] || '';
    t.className   = 'tile' + (currentGuess[i] ? ' filled' : ' empty');
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUBMIT GUESS â€” the fixed core loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.submitGuess = async function() {
  // â”€â”€ Guard: stop if game is already over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (gameOver) return;

  const inp   = document.getElementById('guess-input');
  const guess = inp.value.toUpperCase().trim();

  // â”€â”€ Validate length â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (guess.length !== wordLength) {
    showToast(`Word must be exactly ${wordLength} letters.`, 'warn');
    shakeRow(document.getElementById(`row-${guessCount}`));
    return;
  }

  // â”€â”€ Validate characters: A-Z only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!/^[A-Z]+$/.test(guess)) {
    showToast('Only letters Aâ€“Z are allowed. No numbers or symbols.', 'warn');
    shakeRow(document.getElementById(`row-${guessCount}`));
    inp.value = '';
    updateCurrentRow('');
    return;
  }

  // â”€â”€ Disable controls to prevent double-submit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inp.disabled = true;
  document.getElementById('submit-btn').disabled = true;

  // â”€â”€ Evaluate guess against the secret word â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // evaluateGuess(secret, guess) â†’ array of 'correct' | 'present' | 'absent'
  // A WIN requires ALL positions to return 'correct' â€” exact character match
  const result = evaluateGuess(secretWord, guess);
  const isWin  = result.length === wordLength && result.every(r => r === 'correct');

  // â”€â”€ For online guest: push guess to Firebase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Host's listener will pick this up for the spectator view
  if (mode === 'online' && !isHost) {
    await push(ref(db, 'rooms/' + roomId + '/guesses'), {
      guess,
      ts: Date.now()
    });
  }

  // â”€â”€ Render tiles and keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  buildTileRow(document.getElementById(`row-${guessCount}`), guess, result);
  updateKeyboard(document.getElementById('keyboard'), guess, result);

  // Sound feedback
  if (isWin) {
    playSound('correct');
  } else if (result.includes('correct') || result.includes('present')) {
    playSound('present');
  } else {
    playSound('absent');
  }

  // â”€â”€ Advance attempt counter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  guessCount++;
  const attemptsLeft = maxAttempts - guessCount;
  document.getElementById('sb-attempts').textContent = attemptsLeft;

  // â”€â”€ Clear input field â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inp.value    = '';
  currentGuess = '';

  // â”€â”€ WIN: all letters correct â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isWin) {
    handleGameEnd(true, guess);
    return;   // controls stay disabled â€” game over
  }

  // â”€â”€ LOSS: exhausted all attempts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (guessCount >= maxAttempts) {
    handleGameEnd(false, guess);
    return;   // controls stay disabled â€” game over
  }

  // â”€â”€ Game continues â€” re-enable input for next attempt â”€â”€â”€â”€â”€â”€
  inp.disabled = false;
  document.getElementById('submit-btn').disabled = false;
  inp.focus();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME END â€” runs at most ONCE, protected by gameOver flag
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleGameEnd(won, finalGuess) {
  // â”€â”€ Critical guard: prevent double invocation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (gameOver) return;
  gameOver = true;  // lock IMMEDIATELY before any async work

  // Stop timer
  if (timer) timer.stop();

  // Detach Firebase listener
  if (_guessUnsub) { _guessUnsub(); _guessUnsub = null; }

  // Hide input UI
  document.getElementById('guess-input-area').classList.add('hidden');
  document.getElementById('keyboard').innerHTML = '';

  // Victory / defeat effects
  if (won) { confettiBurst(); playSound('win');  }
  else     {                  playSound('lose'); }

  // â”€â”€ DB updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const today   = todayStr();
  const userRef = ref(db, 'users/' + currentUser.uid);
  const uSnap   = await get(userRef);
  const ud      = uSnap.val();
  const updates = { totalGames: (ud.totalGames || 0) + 1 };
  let   rewardMsg = '';

  // â”€â”€ OFFLINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (mode === 'offline') {
    if (won) { updates.wins   = (ud.wins   || 0) + 1; }
    else     { updates.losses = (ud.losses || 0) + 1; }
  }

  // â”€â”€ ONLINE â€” GUEST (owns outcome write) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  else if (mode === 'online' && !isHost) {
    if (won) {
      // Guest wins: receives 2Ã— the pot (both bets)
      updates.wins  = (ud.wins  || 0) + 1;
      updates.score = (ud.score || 0) + betScore * 2;
      rewardMsg     = `+${betScore * 2} â­ score!`;

      // Host loses: get a loss on record (they already lost their bet)
      const rSnap = await get(ref(db, 'rooms/' + roomId));
      if (rSnap.exists()) {
        const rData = rSnap.val();
        if (rData.hostUid) {
          const hSnap = await get(ref(db, 'users/' + rData.hostUid));
          if (hSnap.exists()) {
            const hd = hSnap.val();
            await update(ref(db, 'users/' + rData.hostUid), {
              losses:     (hd.losses     || 0) + 1,
              totalGames: (hd.totalGames || 0) + 1
            });
          }
        }
      }

      // Write room outcome â€” host's watcher will detect 'finished' status
      await update(ref(db, 'rooms/' + roomId), {
        status: 'finished',
        winner: currentUser.username
      });

    } else {
      // Guest loses: host wins the pot
      updates.losses = (ud.losses || 0) + 1;

      const rSnap = await get(ref(db, 'rooms/' + roomId));
      if (rSnap.exists()) {
        const rData = rSnap.val();
        if (rData.hostUid) {
          const hSnap = await get(ref(db, 'users/' + rData.hostUid));
          if (hSnap.exists()) {
            const hd = hSnap.val();
            await update(ref(db, 'users/' + rData.hostUid), {
              wins:       (hd.wins       || 0) + 1,
              score:      (hd.score      || 0) + betScore * 2,  // host gets both bets
              totalGames: (hd.totalGames || 0) + 1
            });
          }
        }
        // Write room outcome
        await update(ref(db, 'rooms/' + roomId), {
          status: 'finished',
          winner: rData.host
        });
      }
    }
  }

  // â”€â”€ ONLINE â€” HOST (outcome written by guest; host shown via showHostResult) â”€â”€
  else if (mode === 'online' && isHost) {
    // The guest side writes the room status; listenToGuestGuesses() â†’ showHostResult().
    // Don't do anything here â€” it would cause a race condition / double DB write.
    // The host's result UI is triggered from listenToGuestGuesses via get(room).
    return;
  }

  // â”€â”€ DAILY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  else if (mode === 'daily') {
    const daily = window._dailyData;
    await set(ref(db, `dailyResults/${today}/${currentUser.username}`), {
      result:    won ? 'win' : 'lose',
      timeTaken: Date.now(),
      timestamp: Date.now()
    });
    if (won) {
      updates.wins   = (ud.wins   || 0) + 1;
      updates.money  = (ud.money  || 0) + (daily.rewardMoney || 0);
      updates.score  = (ud.score  || 0) + (daily.rewardScore || 0);
      rewardMsg = `+${daily.rewardMoney} ğŸ’°  +${daily.rewardScore} â­`;
    } else {
      updates.losses = (ud.losses || 0) + 1;
    }
  }

  // â”€â”€ Write player stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  await update(userRef, updates);

  // â”€â”€ Refresh session & award achievements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fresh     = await get(userRef);
  const freshData = fresh.val();
  saveSession({ uid: currentUser.uid, ...freshData });

  const newAch = await checkAchievements(freshData, currentUser.uid, db, ref, update);
  if (newAch.length > 0) {
    const a = ACHIEVEMENTS.find(x => x.id === newAch[0]);
    if (a) setTimeout(() => showToast(`ğŸ– Achievement: ${a.label}!`, 'success', 4500), 1800);
  }

  // â”€â”€ Show result overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  setTimeout(() => {
    document.getElementById('res-emoji').textContent = won ? 'ğŸ†' : 'ğŸ’€';
    document.getElementById('res-title').textContent = won ? 'VICTORY!' : 'DEFEATED!';
    document.getElementById('res-word').textContent  = secretWord;
    document.getElementById('res-msg').textContent   = won
      ? `Cracked in ${guessCount} attempt${guessCount !== 1 ? 's' : ''}! ${rewardMsg}`
      : `The word was: ${secretWord}. Better luck next time!`;
    document.getElementById('result-overlay').classList.add('open');
  }, 700);
}

window.playAgain = function() {
  document.getElementById('result-overlay').classList.remove('open');
  window.location.href = 'game.html';
};

// â”€â”€ Kick off init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init();
</script>
</body>
</html>
